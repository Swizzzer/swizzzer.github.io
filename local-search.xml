<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>面向对象课程第一章:Java基础</title>
    <link href="/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AF%BE%E7%A8%8B%E7%AC%AC%E4%B8%80%E7%AB%A0-Java%E5%9F%BA%E7%A1%80.html"/>
    <url>/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AF%BE%E7%A8%8B%E7%AC%AC%E4%B8%80%E7%AB%A0-Java%E5%9F%BA%E7%A1%80.html</url>
    
    <content type="html"><![CDATA[<h1 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h1><p>因为 Java 语言和 C&#x2F;C++ 在很多语法上相似甚至完全一致（例如各种控制语句），因此这里只列出 Java 与 C 家族不同的语言特性。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>Java 一共有 8 种「基本数据类型」。</p><table><thead><tr><th>类型</th><th>空间</th><th>范围</th><th>备注</th></tr></thead><tbody><tr><td>byte</td><td>1 字节</td><td>$-128 \text{–} 127$</td><td></td></tr><tr><td>short</td><td>2 字节</td><td>$-2^{15}\text{–}2^{15}-1$</td><td></td></tr><tr><td>int</td><td>4 字节</td><td>$-2^{31}\text{–}2^{31} - 1$</td><td></td></tr><tr><td>long</td><td>8 字节</td><td>$-2^{63}\text{–}2^{63} - 1$</td><td>声明常量要加「L」</td></tr><tr><td>float</td><td>4 字节</td><td>——</td><td>声明常量要加「F」</td></tr><tr><td>double</td><td>8 字节</td><td>——</td><td>浮点数的默认类型</td></tr><tr><td>char</td><td>16 字节</td><td>UTF-16</td><td></td></tr><tr><td>boolean</td><td>——</td><td>false 或 true</td><td>不能用 0 和非 0 代替</td></tr></tbody></table><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>类 <code>class</code>、接口 <code>interface</code> 和数组都是引用类型。</p><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>Java 的标准输入流是一个 <code>InputStream</code> 对象，有两种常用的读取方式：</p><ul><li><p>用读字符流的方法将 <code>System.in</code> 读到一个 <code>BufferedReader</code> 中。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">stdin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));<br>stdin.readLine() <span class="hljs-comment">// &lt;= 得到用户输入的字符串</span><br></code></pre></td></tr></table></figure></li><li><p>用 <code>java.util.Scanner</code> 对 <code>System.in</code> 进行封装。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Scanner</span> <span class="hljs-variable">stdin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>stdin.nextLine() <span class="hljs-comment">// &lt;= 得到用户输入的字符串</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><ul><li><code>System.out.print()</code> 不换行输出。</li><li><code>System.out.println()</code> 换行输出。</li><li><code>System.out.printf()</code> 格式化输出，语法同 C 标准库的 <code>printf()</code>。</li></ul><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>Java 中的「数组」是确定长度的，一经创建就不能再加长了。</p><h3 id="声明和创建"><a href="#声明和创建" class="headerlink" title="声明和创建"></a>声明和创建</h3><p>在创建数组时，要么指定长度，要么给出所有的项。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>]; <span class="hljs-comment">// 指定长度</span><br><span class="hljs-type">double</span>[] anotherArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[]&#123; <span class="hljs-number">2.1</span>, <span class="hljs-number">4.5</span>, <span class="hljs-number">4.2</span> &#125;; <span class="hljs-comment">// 指定项</span><br></code></pre></td></tr></table></figure><h3 id="长度和索引"><a href="#长度和索引" class="headerlink" title="长度和索引"></a>长度和索引</h3><p>可以使用 <code>arr.length</code> 得到一个数组的长度。数组的下标从 0 开始，到 <code>length - 1</code> 结束。</p><h3 id="数组是引用类型"><a href="#数组是引用类型" class="headerlink" title="数组是引用类型"></a>数组是引用类型</h3><p>所谓「引用类型」，可以理解为 C 家族中的「指针」。下面的代码解释了「引用」的本质。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123; <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span> &#125;;<br>System.out.println(arr[<span class="hljs-number">2</span>]);       <span class="hljs-comment">// 打印 2</span><br>arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123; <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span> &#125;;    <span class="hljs-comment">// 现在 arr 指向了一个新的数组，旧的数组会被 JVM 回收</span><br>System.out.println(arr[<span class="hljs-number">2</span>]);       <span class="hljs-comment">// 打印 6</span><br></code></pre></td></tr></table></figure><h3 id="数组中的引用类型"><a href="#数组中的引用类型" class="headerlink" title="数组中的引用类型"></a>数组中的引用类型</h3><p>思考下面代码的输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] name = &#123; <span class="hljs-string">&quot;HIT&quot;</span>, <span class="hljs-string">&quot;SZ&quot;</span>, <span class="hljs-string">&quot;C++&quot;</span> &#125;;<br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> name[<span class="hljs-number">2</span>];<br>name[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;Java&quot;</span>;<br>System.out.println(name[<span class="hljs-number">2</span>]);<br>System.out.println(s);<br></code></pre></td></tr></table></figure><p>结果为</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">Java</span><br><span class="hljs-comment">C</span><span class="hljs-literal">++</span><br></code></pre></td></tr></table></figure><p>内存映射图：</p><p><img src="/../assets/basicOfJava_1.png" alt="basicOfJava_1"></p><h3 id="「多维」数组"><a href="#「多维」数组" class="headerlink" title="「多维」数组"></a>「多维」数组</h3><p>没有所谓的「多维数组」，它本质上是「数组的数组」。例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[][] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">5</span>][];<br></code></pre></td></tr></table></figure><p>是一个长度为 5 的「数组」数组，它内部的 5 个数组因为现在还没有初始化，所以长度可以不给出。我们当然也可以在定义给出所有的项，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[][] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123; &#123; <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125; &#125;;<br></code></pre></td></tr></table></figure><p>显然，多维数组中的每一行不一定要一样长。</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>Java 的异常捕获结构为 <code>try</code> - <code>catch</code> - <code>finally</code>。其中 <code>catch</code> 和 <code>finally</code> 可以只出现一个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// 做点啥</span><br>&#125; <span class="hljs-keyword">catch</span> (<span class="hljs-comment">/** 异常 **/</span>) &#123;<br>    <span class="hljs-comment">// 出现异常时做的事</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-comment">// 不管出现异常与否都要做的事</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><ol><li>定义：客观存在的具体实体，具有明确定义的状态和行为</li><li>特征：标识符、属性、操作<ol><li>属性：与对象关联的变量，描述对象的静态特性</li><li>操作：与对相关联的函数，描述对象的动态特性</li></ol></li></ol><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><ol><li>与对象<ol><li>类是对象的抽象，是创建对象的模板</li><li>对象是类的具体事例</li><li>同一个类可以定义多个对象</li></ol></li><li>二者比较<ol><li>类是静态的，在程序设计的时候就定义好了</li><li>对象是动态的，在程序执行的时候可以被创建、修改、删除</li></ol></li></ol><h3 id="类的构造"><a href="#类的构造" class="headerlink" title="类的构造"></a>类的构造</h3><p>类的访问权限：</p><p><img src="/../assets/basicOfJava_2.png" alt="basicOfJava_2"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 见上表</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">private</span> String name;    <span class="hljs-comment">// private: 只有本类能访问。</span><br><span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> age;      <span class="hljs-comment">// protected: 包外不能访问。但如果子类在包外，也能访问。</span><br><span class="hljs-type">int</span> id;                 <span class="hljs-comment">// default: 包外不能访问。如果子类在包外，也不能访问。</span><br> <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> gender;  <span class="hljs-comment">// public: 谁都可以访问</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br><span class="hljs-built_in">this</span>.name = name;<br><span class="hljs-built_in">this</span>.age = age;<br>id = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name)</span> &#123;<br><span class="hljs-built_in">this</span>(name, <span class="hljs-number">22</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="静态类"><a href="#静态类" class="headerlink" title="静态类"></a>静态类</h3><ol><li>静态成员属于类所有而不是某一具体对象所有</li><li>加载时间<ol><li>静态成员在类加载的时候被静态地分配地址空间和方法的入口地址</li><li>静态属性当且仅当在类初次加载的时候初始化</li></ol></li><li>实例<ol><li>非静态对象在创建对象的时候初始化，存在多个实例副本，各个对象之间的副本不互相影响</li><li>静态对象被所有的对象共享，在内存中只有一个副本</li></ol></li><li><code>static</code> 属性是全局属性，可以直接通过类名访问，所以又叫类属性</li><li>调用限制<ol><li><code>static</code> 方法不可访问非 <code>static</code> 的方法：非 <code>static</code> 的对象必须要实例化才能访问调</li><li>非 <code>static</code> 的方法可以访问 <code>static</code> 的方法：通过类名访问</li></ol></li><li>静态块<ol><li><p>可以放在类的任何地方，类中可以有多个 <code>static</code> 块</p></li><li><p>语法：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">static</span> &#123;<br>totalNum = <span class="hljs-number">10000</span>;<br>System.out.println(<span class="hljs-string">&quot;static block run!&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>生命周期：在类加载的时候执行且只执行一次</p></li><li><p>用法：用于初始化静态变量和调用静态方法</p></li></ol></li><li>静态是否破坏了面向对象的特性？<ol><li>静态属于类而非具体对象</li><li>具有一定程度上的全局性：初始化时加载到内存，并且所有对象有访问权限</li><li>保持类的封装性</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>课程笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>锐评铃芽之旅</title>
    <link href="/%E9%94%90%E8%AF%84%E9%93%83%E8%8A%BD%E4%B9%8B%E6%97%85.html"/>
    <url>/%E9%94%90%E8%AF%84%E9%93%83%E8%8A%BD%E4%B9%8B%E6%97%85.html</url>
    
    <content type="html"><![CDATA[<h1 id="铃芽之旅所传达的"><a href="#铃芽之旅所传达的" class="headerlink" title="铃芽之旅所传达的"></a>铃芽之旅所传达的</h1><p>称&lt;铃芽之旅&gt;为新海诚三部曲之三实在是很有道理.沿袭着一贯的灾难描写的文脉,铃芽对于灾难的描写似乎更为翔实,灾难甚至成为了本片剧情的核心驱动力,对灾难中情感的表达也成为了本片表达的核心–不同于前两部仅仅着眼于对爱情的描写,人与人之间的更泛化的情感在本片中被显式地推到了台前.不论是关门时候男主明确的昭告,希望在当下的幸福能延续更久;或是女主在关门时对土地上曾有的生生不息的想象;亦或是门后的常世中宁静的生活,影片中出现的种种要素都在试图讨论着这份灾难中的泛化的感情.它关乎人与人之间的一切情感,或者说,正是人与人之间朴素的温情.</p><p>几乎可以断言的是,正是为了处理这样的更泛化的感情,新海才会选择公路片(至少算是有公路要素的片子?)这种形式以及其带来的崭新的展开方式.正是如此才让更多人的相遇成为可能,才让人在无情的灾难面前得以先验地认识到情感的温度.而对于感情的后验式的认知则是由男女主这条线来处理的.两种不同属性的关系,分别勾勒着对于感情的先验的和后验的认知.</p><h1 id="传达到了吗"><a href="#传达到了吗" class="headerlink" title="传达到了吗"></a>传达到了吗</h1><p>事实上,两条不同的勾勒路线都没有很好地完成使命.对情感的后验式的认知要想成立,首先要求的是这份情感要先验地存在–而片中男女主关系其实是很稀薄的.诚然影片有着”女主在小时候在常世中就见过男主”这种叙事诡计,但是这并不能弥补恋爱的”单薄”.一段关系如果要更馥郁,势必需要一些私密的叙事空间,像是&lt;君名&gt;中两人长期的互换身体体验对方的私密生活,或是&lt;天气&gt;中只属于两人的奋斗历程.而这样的私密空间在铃芽中是几乎不存在的.相比于&lt;君名&gt;&lt;天气&gt;中新海宁愿用一个甚至多个场景去单独呈现主角间的互动,新海却让铃芽的男主在开场15分钟后即陷入掉线状态,后期也只是一直为了追寻大臣而奔忙.虽然本片的恋爱的确平淡,但是在这样的奔忙之后,却是女主的”我要去找喜欢的人了”这样一句台词直接点明了亲密关系,这种关系的厚度显然是不足的.</p><p>先验式认知的情感处理得也有同样的缺乏厚度的问题.公路旅途上的相遇虽然直白地试图展现人与人之间的温情,但是影像上的处理是如此泛化,三幕场景都只是点到为止.新海诚当然是内敛的,但是内敛不意味着蜻蜓点水,不意味着主角自身情感对观众情感的引导完全失位.为什么是失位的呢?关门时涌入铃芽耳中的是泛泛的言语和声音,人间的温情缺少一个确切的情感落地点;姨妈对铃芽的爱也是泛泛而谈–姨妈为了铃芽做的牺牲几乎只有在一次争吵中草草交代了事,同样缺少确切的情感落地点;妈妈对铃芽的爱更是几无笔墨,灾难中最亲密的人之间的情感更成为了无法落地的空中楼阁.当感情无法锚定在一个确切的时空位置,只能流于泛泛,感情的厚度必然是不足的.</p><p>关键场景的缺失,让全片对灾难的表达同样浅尝辄止.在&lt;君名&gt;中,我们有陨石坑上主角的相见;在&lt;天气&gt;中,我们有男女主的天空坠落和男主的长距离奔跑–但铃芽中缺少这么一个具有力度的场景.唯一的力度可能也只是来自于铃芽回到老家挖出的日记中写有3.11的那一页,而且也是严重不足的–尽管影片中不时穿插着涂黑日记的画面,但是铃芽找到日记的过程是如此顺利成章–没有任何犹豫和模糊.涂黑日记本身是人脑对创伤性经历不可避免的模糊化的具象,包括前文铃芽对椅子缺腿的原因的闪烁其辞也体现着这种模糊,但是找到日记的过程却没有任何模糊,甚至在找到日记后也没有任何对过往记忆的确认,3.11就这样被直接糊脸–缺少了对记忆碎片的整理,缺少了私人化的情感体验,缺少了影像上的蓄力和角色情感的倾泻,单单通过一个场外的符号,带出的表达力度真的足够吗?我的评断是否定的.而作为全片灾难的集中象征的3.11就这样被轻描淡写,全片的关键场景由此不复存在.</p><p>我们甚至还可以批评片子的演出手段.3D LO的引入让更复杂的镜头成为可能,演出上的奇观自然也多了不少–铃芽开头奔跑的跟摇,椅子追逐猫猫时的多个运动镜头…但是奇观多了就一定好吗?如果奇观没有地基支撑,那么奇观的泛滥就只会像对着观众喊”狼来了”一般,最终使得奇观也无法调动观众的注意力.当然本片不少奇观造的都不错,但是总归是有那么几个缺少地基(比如开头的跟摇).而且我们还没有说到这些奇观画面上的不协调.</p><h1 id="铃芽背后的其他"><a href="#铃芽背后的其他" class="headerlink" title="铃芽背后的其他"></a>铃芽背后的其他</h1><p>尽管闭门师在竭力避免蚓厄的发生,但&lt;铃芽&gt;中却放置了一个不可改变不可避免的”3.11”.由此我们可以断言,&lt;铃芽&gt;某种程度上是对于灾难的再认知–与&lt;你的名字&gt;中试图挽回灾难中失去的爱人,&lt;天气之子&gt;中主动选择爱人拥抱灾难不同的是,&lt;铃芽&gt;中的核心灾难,也即”3.11,”首先是被放在一个不可处置的地位的.因此影片的所有情节都是在接受这一事实的基础上加以展开,而完全不同于前作中的”反抗”要素.</p><p>&lt;铃芽&gt;中的新海在尽力告诉观众,接受灾难并坚定地生活下去才是面对灾难的解药,领悟了这一点后我们就能明白为什么3条腿的草太椅子依然能灵活地奔跑,即使是失去了曾经拥有的一条腿–即使灾后失去了曾经拥有的美好生活,我们依然能接受这一事实,我们生活如常,社会运转如常.</p><p>但是这种如常的背后并非不存在隐忧.灾难带来的伤痛真的就能随着时间流逝,随着一份轻描淡写的”接受”之心,而散入记忆的长河直至无影无踪吗?新海的回答当然是否定的,正如他自述的那样,”3.11”依然是他创作过程中的持续低音;正如影片中那座游乐场,始终停留在人们心中无法抹去;正如铃芽涂黑的一页页日记,总是在梦中闯入她的思绪.</p><p>不如说铃芽执意回老家正是为了寻求一份和解,事实上灾难中的幸存者或许都需要这份和解.铃芽在门中看到的辽阔的常世,那里面并不是悲伤,而是失去了情感的记忆.这种麻木是值得警惕的.可以猜测,要石的身体之所以冷若冰霜,正是因为对失去的哀叹化作了无边的麻木与虚无.幸存者也好,要石也好,都需要在对灾难的反复审视中确认生的可贵,从而让生的动力支撑自己在此时此地多停留一刻甚至一秒.</p><p>&lt;铃芽&gt;关注的正是这种”后灾难”的疗愈,是痛苦背后更深刻的创伤的弥合过程.新海给出的回答,不是随着时间试着遗忘,而是在追思与审视中,了解生的可贵;影片中的灾难不再是一种需要避讳的苦难,而是需要确认的人生必然.</p><p>对新海来说,这何尝不是一种进步呢?</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
      <category>动画</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动画评论</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
